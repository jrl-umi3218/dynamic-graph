// -*- mode: c++ -*-
// Copyright 2010, Fran√ßois Bleibel, Thomas Moulard, Olivier Stasse,
// JRL, CNRS/AIST.
//
// This file is part of dynamic-graph.
// dynamic-graph is free software: you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public License
// as published by the Free Software Foundation, either version 3 of
// the License, or (at your option) any later version.
//
// dynamic-graph is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Lesser Public License for more details.  You should have
// received a copy of the GNU Lesser General Public License along with
// dynamic-graph. If not, see <http://www.gnu.org/licenses/>.

#ifndef DYNAMIC_GRAPH_ENTITY_H
# define DYNAMIC_GRAPH_ENTITY_H
# include <iosfwd>
# include <map>
# include <sstream>
# include <string>

# include <boost/noncopyable.hpp>

# include <dynamic-graph/fwd.hh>
# include <dynamic-graph/dynamic-graph-api.h>
# include <dynamic-graph/exception-factory.h>
# include <dynamic-graph/signal-array.h>
# include <dynamic-graph/signal-base.h>

/// \brief Helper macro for entity declaration.
///
/// This macro should be called in the declaration of all entities.
/// Example:
/// <code>
/// class A : public dynamicgraph::entity
/// {
///   DYNAMIC_GRAPH_ENTITY_DECL();
///
///   public:
//      // your class here
/// };
/// </code>
///
/// Caution: you *MUST* call DYNAMICGRAPH_FACTORY_ENTITY_PLUGIN in the
/// associated source file to ensure that the attributes generated by
/// this macro are correctly initialized.
# define DYNAMIC_GRAPH_ENTITY_DECL()				\
  public:							\
  virtual const std::string& getClassName () const		\
  {								\
    return CLASS_NAME;						\
  }								\
  static const std::string CLASS_NAME

namespace dynamicgraph
{
  /// \ingroup dgraph
  ///
  /// \brief This class represents an entity, i.e. a generic
  /// computational unit that provides input and output signals.
  ///
  /// These signals link the entities together to form a complete
  /// computation graph.  To declare a new entity, please see the
  /// DYNAMICGRAPH_FACTORY_ENTITY_PLUGIN macro in factory.h.
  class DYNAMIC_GRAPH_DLLAPI Entity : private boost::noncopyable
  {
  public:
    typedef std::map< std::string,SignalBase<int>* > SignalMap;
    typedef std::map<const std::string, command::Command*> CommandMap_t;

    explicit Entity (const std::string& name);
    virtual ~Entity  ();

    const std::string& getName  () const
    {
      return name;
    }
    virtual const std::string& getClassName  () const = 0;
    virtual std::string getDocString () const;
    bool hasSignal( const std::string & signame ) const;
    SignalBase<int>& getSignal (const std::string& signalName);
    const SignalBase<int>& getSignal (const std::string& signalName) const;
    std::ostream& displaySignalList(std::ostream& os) const;
    virtual std::ostream& writeGraph (std::ostream& os) const;
    virtual std::ostream& writeCompletionList (std::ostream& os) const;

    virtual void display (std::ostream& os) const;

    virtual SignalBase<int>* test ()
    {
      return 0;
    }

    virtual void test2 (SignalBase<int>*)
    {
      return ;
    }

    const std::string& getCommandList () const;
    CommandMap_t getNewStyleCommandMap();
    command::Command* getNewStyleCommand( const std::string& cmdName );

    SignalMap getSignalMap() const;
  protected:
    void addCommand(const std::string& name,command::Command* command);

    void entityRegistration ();
    void entityDeregistration ();

    void signalRegistration (const SignalArray<int>& signals);
    void signalDeregistration (const std::string& name);

    std::string name;
    SignalMap signalMap;
    CommandMap_t commandMap;
  };

  DYNAMIC_GRAPH_DLLAPI std::ostream&
  operator<< (std::ostream& os, const dynamicgraph::Entity& ent);
} // end of namespace dynamicgraph

#endif //! DYNAMIC_GRAPH_ENTITY_H
